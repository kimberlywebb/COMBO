posterior_sample_fixed = check_and_fix_chains_2stage(n_chains = number_MCMC_chains,
chains_list = posterior_sample,
pistarjj_matrix = pistarjj,
pitildejjj_matrix = pitildejjj,
dim_x, dim_z, dim_v,
n_cat)
posterior_sample_df <- do.call(rbind.data.frame, posterior_sample_fixed)
posterior_sample_df$chain_number <- rep(1:number_MCMC_chains, each = MCMC_sample)
posterior_sample_df$sample <- rep(1:MCMC_sample, number_MCMC_chains)
##########################################
naive_modelstring = naive_model_picker_2stage(prior)
devtools::install_github("kimberlywebb/COMBO")
detach("package:COMBO", unload = TRUE)
library(COMBO)
detach("package:COMBO", unload = TRUE)
devtools::install_github("kimberlywebb/COMBO")
devtools::install_github("kimberlywebb/COMBO")
devtools::document()
devtools::install_github("kimberlywebb/COMBO")
library(COMBO)
detach("package:COMBO", unload = TRUE)
devtools::install_github("kimberlywebb/COMBO")
# Estimate parameters using MCMC.
MCMC_results <- COMBO_MCMC_2stage(Ystar1, Ystar2,
x_matrix = x_matrix,
z1_matrix = z1_matrix,
z2_matrix = z2_matrix,
prior = "uniform",
beta_prior_parameters,
gamma1_prior_parameters,
gamma2_prior_parameters,
naive_gamma2_prior_parameters = gamma1_prior_parameters,
number_MCMC_chains = 4,
MCMC_sample = 6, burn_in = 2)
library(COMBO)
pkgdown::build_site()
pkgdown::build_site()
devtools::check()
devtools::install_github("kimberlywebb/COMBO")
knitr::opts_chunk$set(echo = TRUE,
warning = FALSE, error = FALSE, message = FALSE,
fig.align = "center")
library(ggplot2)
library(kableExtra)
library(COMBO)
library(dplyr)
library(stringr)
# Set seed.
set.seed(123)
# Set sample size, x and z distribution information.
n <- 1000
x_mu <- 0
x_sigma <- 1
z1_shape <- 1
z2_shape <- 1
# Set true parameter values.
true_beta <- matrix(c(1, -2), ncol = 1)
true_gamma1 <- matrix(c(.5, 1, -.5, -1), nrow = 2, byrow = FALSE)
true_gamma2 <- array(c(1.5, 1, .5, .5, -.5, 0, -1, -1), dim = c(2, 2, 2))
# Generate data.
my_data <- COMBO_data_2stage(sample_size = n,
x_mu = x_mu, x_sigma = x_sigma,
z1_shape = z1_shape, z2_shape = z2_shape,
beta = true_beta, gamma1 = true_gamma1,
gamma2 = true_gamma2)
# Save list elements as vectors.
Ystar1 <- my_data[["obs_Ystar1"]]
Ystar2 <- my_data[["obs_Ystar2"]]
x_matrix <- my_data[["x"]]
z1_matrix <- my_data[["z1"]]
z2_matrix <- my_data[["z2"]]
# Supply starting values for all parameters.
starting_values <- rep(1,14)
beta_start <- matrix(starting_values[1:2], ncol = 1)
gamma1_start <- matrix(starting_values[3:6], ncol = 2, nrow = 2, byrow = FALSE)
gamma2_start <- array(starting_values[7:14], dim = c(2,2,2))
# Estimate parameters using the EM-Algorithm.
EM_results <- COMBO_EM_2stage(Ystar1, Ystar2,
x_matrix = x_matrix,
z1_matrix = z1_matrix,
z2_matrix = z2_matrix,
beta_start = beta_start,
gamma1_start = gamma1_start,
gamma2_start = gamma2_start)
EM_results
# Specify parameters for the prior distributions.
unif_lower_beta <- matrix(c(-5, -5, NA, NA), nrow = 2, byrow = TRUE)
unif_upper_beta <- matrix(c(5, 5, NA, NA), nrow = 2, byrow = TRUE)
unif_lower_gamma1 <- array(data = c(-5, NA, -5, NA, -5, NA, -5, NA),
dim = c(2,2,2))
unif_upper_gamma1 <- array(data = c(5, NA, 5, NA, 5, NA, 5, NA),
dim = c(2,2,2))
unif_upper_gamma2 <- array(rep(c(5, NA), 8), dim = c(2,2,2,2))
unif_lower_gamma2 <- array(rep(c(-5, NA), 8), dim = c(2,2,2,2))
beta_prior_parameters <- list(lower = unif_lower_beta, upper = unif_upper_beta)
gamma1_prior_parameters <- list(lower = unif_lower_gamma1, upper = unif_upper_gamma1)
gamma2_prior_parameters <- list(lower = unif_lower_gamma2, upper = unif_upper_gamma2)
# Estimate parameters using MCMC.
MCMC_results <- COMBO_MCMC_2stage(Ystar1, Ystar2,
x_matrix = x_matrix,
z1_matrix = z1_matrix,
z2_matrix = z2_matrix,
prior = "uniform",
beta_prior_parameters,
gamma1_prior_parameters,
gamma2_prior_parameters,
naive_gamma2_prior_parameters = gamma1_prior_parameters,
number_MCMC_chains = 4,
MCMC_sample = 6, burn_in = 2)
#'                                   x_matrix = x_matrix, z1_matrix = z1_matrix,
#'                                   z2_matrix = z2_matrix,
#'                                   prior = "uniform",
#'                                   beta_prior_parameters = beta_prior_parameters,
#'                                   gamma1_prior_parameters = gamma1_prior_parameters,
#'                                   gamma2_prior_parameters = gamma2_prior_parameters,
#'                                   naive_gamma2_prior_parameters = naive_gamma2_prior_parameters,
#'                                   number_MCMC_chains = 2,
#'                                   MCMC_sample = 200, burn_in = 100)
#' MCMC_results$posterior_means_df}
COMBO_MCMC_2stage <- function(Ystar1, Ystar2, x_matrix, z1_matrix, z2_matrix,
prior,
beta_prior_parameters,
gamma1_prior_parameters,
gamma2_prior_parameters,
naive_gamma2_prior_parameters,
number_MCMC_chains = 4,
MCMC_sample = 2000,
burn_in = 1000,
display_progress = TRUE){
Ystar <- Ystar1
Ytilde <- Ystar2
x <- x_matrix
z <- z1_matrix
v <- z2_matrix
gamma_prior_parameters <- gamma1_prior_parameters
delta_prior_parameters <- gamma2_prior_parameters
naive_delta_prior_parameters <- naive_gamma2_prior_parameters
# Define global variables to make the "NOTES" happy.
chain_number <- NULL
parameter_name <- NULL
if (!is.numeric(Ystar) || !is.vector(Ystar))
stop("'Ystar' must be a numeric vector.")
if (length(setdiff(1:2, unique(Ystar))) != 0)
stop("'Ystar' must be coded 1/2, where the reference category is 2.")
sample_size = length(Ystar)
n_cat = 2
# FIX THIS! DIMENSIONS DON'T WORK FOR x, z WITH MORE THAN ONE COL
X = cbind(matrix(1, nrow = sample_size, ncol = 1), x)
Z = cbind(matrix(1, nrow = sample_size, ncol = 1), z)
V = cbind(matrix(1, nrow = sample_size, ncol = 1), v)
dim_x = ncol(X)
dim_z = ncol(Z)
dim_v = ncol(V)
modelstring = model_picker_2stage(prior)
temp_model_file = tempfile()
tmps = file(temp_model_file, "w")
cat(modelstring, file = tmps)
close(tmps)
jags <- jags_picker_2stage(prior, sample_size, dim_x, dim_z, dim_v, n_cat,
Ystar, Ytilde, X, Z, V,
beta_prior_parameters, gamma_prior_parameters,
delta_prior_parameters,
number_MCMC_chains,
model_file = temp_model_file,
display_progress = display_progress)
display_progress_bar <- ifelse(display_progress == TRUE, "text", "none")
posterior_sample = coda.samples(jags,
c('beta', 'gamma1', 'gamma2'),
MCMC_sample,
progress.bar = display_progress_bar)
pistarjj = pistar_by_chain_2stage(n_chains = number_MCMC_chains,
chains_list = posterior_sample,
Z = Z, n = sample_size, n_cat = n_cat)
pitildejjj = pitilde_by_chain(n_chains = number_MCMC_chains,
chains_list = posterior_sample,
V = V, n = sample_size, n_cat = n_cat)
posterior_sample_fixed = check_and_fix_chains_2stage(n_chains = number_MCMC_chains,
chains_list = posterior_sample,
pistarjj_matrix = pistarjj,
pitildejjj_matrix = pitildejjj,
dim_x, dim_z, dim_v,
n_cat)
posterior_sample_df <- do.call(rbind.data.frame, posterior_sample_fixed)
posterior_sample_df$chain_number <- rep(1:number_MCMC_chains, each = MCMC_sample)
posterior_sample_df$sample <- rep(1:MCMC_sample, number_MCMC_chains)
##########################################
naive_modelstring = naive_model_picker_2stage(prior)
naive_temp_model_file = tempfile()
tmps = file(naive_temp_model_file, "w")
cat(naive_modelstring, file = tmps)
close(tmps)
naive_jags <- naive_jags_picker_2stage(prior, sample_size, dim_x, dim_v, n_cat,
Ystar, Ytilde, X, V,
beta_prior_parameters,
naive_delta_prior_parameters,
number_MCMC_chains,
naive_model_file = naive_temp_model_file,
display_progress = display_progress)
naive_posterior_sample = coda.samples(naive_jags,
c('beta', 'gamma'),
MCMC_sample,
progress.bar = display_progress_bar)
naive_posterior_sample_df <- do.call(rbind.data.frame, naive_posterior_sample)
naive_posterior_sample_df$chain_number <- rep(1:number_MCMC_chains, each = MCMC_sample)
naive_posterior_sample_df$sample <- rep(1:MCMC_sample, number_MCMC_chains)
###########################################
beta_names <- paste0("beta[1,", 1:dim_x, "]")
gamma_names <- paste0("gamma1[1,", rep(1:n_cat, dim_z), ",", rep(1:dim_z, each = n_cat), "]")
delta_names <- paste0("gamma2[1,",
rep(1:n_cat, dim_v*dim_v), ",",
rep(rep(1:n_cat, each = dim_v), dim_v), ",",
rep(1:dim_v, each = n_cat * n_cat), "]")
naive_delta_names <- paste0("gamma[1,", rep(1:n_cat, dim_v), ",", rep(1:dim_z, each = n_cat), "]")
naive_posterior_sample_burn <- naive_posterior_sample_df %>%
dplyr::select(dplyr::all_of(beta_names), dplyr::all_of(naive_delta_names),
chain_number, sample) %>%
dplyr::filter(sample > burn_in) %>%
tidyr::gather(parameter_name, sample, beta_names[1]:naive_delta_names[length(naive_delta_names)],
factor_key = TRUE) %>%
dplyr::mutate(parameter_name = paste0("naive_", parameter_name))
naive_posterior_means <- naive_posterior_sample_burn %>%
dplyr::group_by(parameter_name) %>%
dplyr::summarise(posterior_mean = mean(sample),
posterior_median = stats::median(sample)) %>%
dplyr::ungroup()
posterior_sample_burn <- posterior_sample_df %>%
dplyr::select(dplyr::all_of(beta_names), dplyr::all_of(gamma_names),
dplyr::all_of(delta_names),
chain_number, sample) %>%
dplyr::filter(sample > burn_in) %>%
tidyr::gather(parameter_name, sample,
beta_names[1]:delta_names[length(delta_names)], factor_key = TRUE)
posterior_means <- posterior_sample_burn %>%
dplyr::group_by(parameter_name) %>%
dplyr::summarise(posterior_mean = mean(sample),
posterior_median = stats::median(sample)) %>%
dplyr::ungroup()
results = list(posterior_sample_df = posterior_sample_burn,
posterior_means_df = posterior_means,
naive_posterior_sample_df = naive_posterior_sample_burn,
naive_posterior_means_df = naive_posterior_means)
return(results)
}
# Estimate parameters using MCMC.
MCMC_results <- COMBO_MCMC_2stage(Ystar1, Ystar2,
x_matrix = x_matrix,
z1_matrix = z1_matrix,
z2_matrix = z2_matrix,
prior = "uniform",
beta_prior_parameters,
gamma1_prior_parameters,
gamma2_prior_parameters,
naive_gamma2_prior_parameters = gamma1_prior_parameters,
number_MCMC_chains = 4,
MCMC_sample = 6, burn_in = 2)
rm(COMBO_MCMC_2stage)
devtools::document()
library(COMBO)
detach("package:COMBO", unload = TRUE)
devtools::install_github("kimberlywebb/COMBO")
knitr::opts_chunk$set(echo = TRUE,
warning = FALSE, error = FALSE, message = FALSE,
fig.align = "center")
library(ggplot2)
library(kableExtra)
library(COMBO)
library(dplyr)
library(stringr)
# Set seed.
set.seed(123)
# Set sample size, x and z distribution information.
n <- 1000
x_mu <- 0
x_sigma <- 1
z1_shape <- 1
z2_shape <- 1
# Set true parameter values.
true_beta <- matrix(c(1, -2), ncol = 1)
true_gamma1 <- matrix(c(.5, 1, -.5, -1), nrow = 2, byrow = FALSE)
true_gamma2 <- array(c(1.5, 1, .5, .5, -.5, 0, -1, -1), dim = c(2, 2, 2))
# Generate data.
my_data <- COMBO_data_2stage(sample_size = n,
x_mu = x_mu, x_sigma = x_sigma,
z1_shape = z1_shape, z2_shape = z2_shape,
beta = true_beta, gamma1 = true_gamma1,
gamma2 = true_gamma2)
devtools::install_github("kimberlywebb/COMBO")
knitr::opts_chunk$set(echo = TRUE,
warning = FALSE, error = FALSE, message = FALSE,
fig.align = "center")
library(ggplot2)
library(kableExtra)
library(COMBO)
library(dplyr)
library(stringr)
# Set seed.
set.seed(123)
# Set sample size, x and z distribution information.
n <- 1000
x_mu <- 0
x_sigma <- 1
z1_shape <- 1
z2_shape <- 1
# Set true parameter values.
true_beta <- matrix(c(1, -2), ncol = 1)
true_gamma1 <- matrix(c(.5, 1, -.5, -1), nrow = 2, byrow = FALSE)
true_gamma2 <- array(c(1.5, 1, .5, .5, -.5, 0, -1, -1), dim = c(2, 2, 2))
# Generate data.
my_data <- COMBO_data_2stage(sample_size = n,
x_mu = x_mu, x_sigma = x_sigma,
z1_shape = z1_shape, z2_shape = z2_shape,
beta = true_beta, gamma1 = true_gamma1,
gamma2 = true_gamma2)
# Save list elements as vectors.
Ystar1 <- my_data[["obs_Ystar1"]]
Ystar2 <- my_data[["obs_Ystar2"]]
x_matrix <- my_data[["x"]]
z1_matrix <- my_data[["z1"]]
z2_matrix <- my_data[["z2"]]
# Supply starting values for all parameters.
starting_values <- rep(1,14)
beta_start <- matrix(starting_values[1:2], ncol = 1)
gamma1_start <- matrix(starting_values[3:6], ncol = 2, nrow = 2, byrow = FALSE)
gamma2_start <- array(starting_values[7:14], dim = c(2,2,2))
# Estimate parameters using the EM-Algorithm.
EM_results <- COMBO_EM_2stage(Ystar1, Ystar2,
x_matrix = x_matrix,
z1_matrix = z1_matrix,
z2_matrix = z2_matrix,
beta_start = beta_start,
gamma1_start = gamma1_start,
gamma2_start = gamma2_start)
EM_results
# Specify parameters for the prior distributions.
unif_lower_beta <- matrix(c(-5, -5, NA, NA), nrow = 2, byrow = TRUE)
unif_upper_beta <- matrix(c(5, 5, NA, NA), nrow = 2, byrow = TRUE)
unif_lower_gamma1 <- array(data = c(-5, NA, -5, NA, -5, NA, -5, NA),
dim = c(2,2,2))
unif_upper_gamma1 <- array(data = c(5, NA, 5, NA, 5, NA, 5, NA),
dim = c(2,2,2))
unif_upper_gamma2 <- array(rep(c(5, NA), 8), dim = c(2,2,2,2))
unif_lower_gamma2 <- array(rep(c(-5, NA), 8), dim = c(2,2,2,2))
beta_prior_parameters <- list(lower = unif_lower_beta, upper = unif_upper_beta)
gamma1_prior_parameters <- list(lower = unif_lower_gamma1, upper = unif_upper_gamma1)
gamma2_prior_parameters <- list(lower = unif_lower_gamma2, upper = unif_upper_gamma2)
# Estimate parameters using MCMC.
MCMC_results <- COMBO_MCMC_2stage(Ystar1, Ystar2,
x_matrix = x_matrix,
z1_matrix = z1_matrix,
z2_matrix = z2_matrix,
prior = "uniform",
beta_prior_parameters,
gamma1_prior_parameters,
gamma2_prior_parameters,
naive_gamma2_prior_parameters = gamma1_prior_parameters,
number_MCMC_chains = 4,
MCMC_sample = 6, burn_in = 2)
devtools::document()
library(COMBO)
detach("package:COMBO", unload = TRUE)
devtools::install_github("kimberlywebb/COMBO")
library(COMBO)
COMBO:::naive_model_picker_2stage()
COMBO:::naive_model_picker_2stage
knitr::opts_chunk$set(echo = TRUE,
warning = FALSE, error = FALSE, message = FALSE,
fig.align = "center")
library(ggplot2)
library(kableExtra)
library(COMBO)
library(dplyr)
library(stringr)
# Set seed.
set.seed(123)
# Set sample size, x and z distribution information.
n <- 1000
x_mu <- 0
x_sigma <- 1
z1_shape <- 1
z2_shape <- 1
# Set true parameter values.
true_beta <- matrix(c(1, -2), ncol = 1)
true_gamma1 <- matrix(c(.5, 1, -.5, -1), nrow = 2, byrow = FALSE)
true_gamma2 <- array(c(1.5, 1, .5, .5, -.5, 0, -1, -1), dim = c(2, 2, 2))
# Generate data.
my_data <- COMBO_data_2stage(sample_size = n,
x_mu = x_mu, x_sigma = x_sigma,
z1_shape = z1_shape, z2_shape = z2_shape,
beta = true_beta, gamma1 = true_gamma1,
gamma2 = true_gamma2)
# Save list elements as vectors.
Ystar1 <- my_data[["obs_Ystar1"]]
Ystar2 <- my_data[["obs_Ystar2"]]
x_matrix <- my_data[["x"]]
z1_matrix <- my_data[["z1"]]
z2_matrix <- my_data[["z2"]]
# Supply starting values for all parameters.
starting_values <- rep(1,14)
beta_start <- matrix(starting_values[1:2], ncol = 1)
gamma1_start <- matrix(starting_values[3:6], ncol = 2, nrow = 2, byrow = FALSE)
gamma2_start <- array(starting_values[7:14], dim = c(2,2,2))
# Estimate parameters using the EM-Algorithm.
EM_results <- COMBO_EM_2stage(Ystar1, Ystar2,
x_matrix = x_matrix,
z1_matrix = z1_matrix,
z2_matrix = z2_matrix,
beta_start = beta_start,
gamma1_start = gamma1_start,
gamma2_start = gamma2_start)
EM_results
prior = "uniform"
naive_gamma2_prior_parameters = gamma1_prior_parameters
number_MCMC_chains = 4
# Specify parameters for the prior distributions.
unif_lower_beta <- matrix(c(-5, -5, NA, NA), nrow = 2, byrow = TRUE)
unif_upper_beta <- matrix(c(5, 5, NA, NA), nrow = 2, byrow = TRUE)
unif_lower_gamma1 <- array(data = c(-5, NA, -5, NA, -5, NA, -5, NA),
dim = c(2,2,2))
unif_upper_gamma1 <- array(data = c(5, NA, 5, NA, 5, NA, 5, NA),
dim = c(2,2,2))
unif_upper_gamma2 <- array(rep(c(5, NA), 8), dim = c(2,2,2,2))
unif_lower_gamma2 <- array(rep(c(-5, NA), 8), dim = c(2,2,2,2))
beta_prior_parameters <- list(lower = unif_lower_beta, upper = unif_upper_beta)
gamma1_prior_parameters <- list(lower = unif_lower_gamma1, upper = unif_upper_gamma1)
gamma2_prior_parameters <- list(lower = unif_lower_gamma2, upper = unif_upper_gamma2)
naive_gamma2_prior_parameters = gamma1_prior_parameters
MCMC_sample = 6
burn_in = 2
##########################################
naive_modelstring = naive_model_picker_2stage(prior)
##########################################
naive_modelstring = COMBO:::naive_model_picker_2stage(prior)
naive_temp_model_file = tempfile()
tmps = file(naive_temp_model_file, "w")
cat(naive_modelstring, file = tmps)
close(tmps)
naive_jags <- COMBO:::naive_jags_picker_2stage(prior, sample_size, dim_x, dim_v, n_cat,
Ystar, Ytilde, X, V,
beta_prior_parameters,
naive_delta_prior_parameters,
number_MCMC_chains,
naive_model_file = naive_temp_model_file,
display_progress = display_progress)
naive_jags <- COMBO:::naive_jags_picker_2stage(prior, sample_size, dim_x, dim_v, n_cat,
Ystar, Ytilde, X, V,
beta_prior_parameters,
naive_delta_prior_parameters,
number_MCMC_chains,
naive_model_file = naive_temp_model_file,
display_progress = TRUE)
sample_size <- n
naive_jags <- COMBO:::naive_jags_picker_2stage(prior, sample_size, dim_x, dim_v, n_cat,
Ystar, Ytilde, X, V,
beta_prior_parameters,
naive_delta_prior_parameters,
number_MCMC_chains,
naive_model_file = naive_temp_model_file,
display_progress = TRUE)
Ystar <- Ystar1
Ytilde <- Ystar2
x <- x_matrix
z <- z1_matrix
v <- z2_matrix
gamma_prior_parameters <- gamma1_prior_parameters
delta_prior_parameters <- gamma2_prior_parameters
naive_delta_prior_parameters <- naive_gamma2_prior_parameters
sample_size = length(Ystar)
n_cat = 2
# FIX THIS! DIMENSIONS DON'T WORK FOR x, z WITH MORE THAN ONE COL
X = cbind(matrix(1, nrow = sample_size, ncol = 1), x)
Z = cbind(matrix(1, nrow = sample_size, ncol = 1), z)
V = cbind(matrix(1, nrow = sample_size, ncol = 1), v)
dim_x = ncol(X)
dim_z = ncol(Z)
dim_v = ncol(V)
naive_jags <- COMBO:::naive_jags_picker_2stage(prior, sample_size, dim_x, dim_v, n_cat,
Ystar, Ytilde, X, V,
beta_prior_parameters,
naive_delta_prior_parameters,
number_MCMC_chains,
naive_model_file = naive_temp_model_file,
display_progress = display_progress)
naive_jags <- COMBO:::naive_jags_picker_2stage(prior, sample_size, dim_x, dim_v, n_cat,
Ystar, Ytilde, X, V,
beta_prior_parameters,
naive_delta_prior_parameters,
number_MCMC_chains,
naive_model_file = naive_temp_model_file,
display_progress = TRUE)
naive_posterior_sample = coda.samples(naive_jags,
c('beta', 'gamma'),
MCMC_sample,
progress.bar = display_progress_bar)
library(rjags)
naive_posterior_sample = coda.samples(naive_jags,
c('beta', 'gamma'),
MCMC_sample,
progress.bar = TRUE)
naive_posterior_sample = coda.samples(naive_jags,
c('beta', 'gamma2'),
MCMC_sample,
progress.bar = TRUE)
naive_posterior_sample = coda.samples(naive_jags,
c('beta', 'gamma2'),
MCMC_sample,
progress.bar = display_progress_bar)
View(naive_jags)
display_progress_bar <- TRUE
naive_posterior_sample = coda.samples(naive_jags,
c('beta', 'gamma2'),
MCMC_sample,
progress.bar = display_progress_bar)
