rep(rep(1:n_cat, each = dim_v), dim_v), ",",
rep(1:dim_v, each = n_cat * n_cat), "]")
delta_j1_names <- which(substring(delta_names, 12, 12) == 1)
delta_j2_names <- which(substring(delta_names, 12, 12) == 2)
delta_j1 <- matrix(chain_colMeans[delta_names[delta_j1_names]],
ncol = 2, byrow = TRUE)
delta_j2 <- matrix(chain_colMeans[delta_names[delta_j2_names]],
ncol = 2, byrow = TRUE)
delta <- array(c(delta_j1, delta_j2), dim = c(dim_v, n_cat, n_cat))
exp_vd1 = exp(V %*% delta[,,1])
exp_vd2 = exp(V %*% delta[,,2])
pi_denominator1 = apply(exp_vd1, FUN = sum_every_n1, n, MARGIN = 2)
pi_result1 = exp_vd1 / rbind(pi_denominator1)
pi_denominator2 = apply(exp_vd2, FUN = sum_every_n1, n, MARGIN = 2)
pi_result2 = exp_vd2 / rbind(pi_denominator2)
pitilde_matrix1 = rbind(pi_result1,
1 - apply(pi_result1,
FUN = sum_every_n, n = n,
MARGIN = 2))
pitilde_matrix2 = rbind(pi_result2,
1 - apply(pi_result2,
FUN = sum_every_n, n = n,
MARGIN = 2))
pitilde_array = array(c(pitilde_matrix1, pitilde_matrix2),
dim = c(dim(pitilde_matrix1), 2))
return(pitilde_array)
}
posterior_sample_fixed = check_and_fix_chains_2stage(n_chains = number_MCMC_chains,
chains_list = posterior_sample,
pistarjj_matrix = pistarjj,
pitildejjj_matrix = pitildejjj,
dim_x, dim_z, dim_v,
n_cat)
pitildejjj = pitilde_by_chain(n_chains = number_MCMC_chains,
chains_list = posterior_sample,
V = V, n = sample_size, n_cat = n_cat)
#'   the first-stage observed outcome, \eqn{Y^*}, and the second-stage observed
#'   outcome \eqn{\tilde{Y}} can take.
#'
#' @return \code{label_switch_2stage} returns a named matrix of MCMC posterior samples for
#'   all parameters after performing label switching according the following pattern:
#'   all \eqn{\beta} terms are multiplied by -1, all \eqn{\gamma} and \eqn{\delta} terms are "swapped"
#'   with the opposite \code{j} index.
#'
#' @importFrom stats rnorm rmultinom
#'
label_switch_2stage <- function(chain_matrix, dim_x, dim_z, dim_v, n_cat){
beta_names <- paste0("beta[1,", 1:dim_x, "]")
gamma_names <- paste0("gamma[1,", rep(1:n_cat, dim_z), ",", rep(1:dim_z, each = n_cat), "]")
delta_names <- paste0("delta[1,",
rep(1:n_cat, dim_v*dim_v), ",",
rep(rep(1:n_cat, each = dim_v), dim_v), ",",
rep(1:dim_v, each = n_cat * n_cat), "]")
beta_cols <- which(colnames(chain_matrix) %in% beta_names)
gamma_cols <- which(colnames(chain_matrix) %in% gamma_names)
delta_cols <- which(colnames(chain_matrix) %in% delta_names)
n_flip_gammas <- length(gamma_cols) / 2
gamma_cols_1 <- gamma_cols[c(TRUE, FALSE)]
gamma_cols_2 <- gamma_cols[c(FALSE, TRUE)]
n_flip_deltas <- length(delta_cols) / 2
delta_cols_1 <- delta_cols[c(TRUE, TRUE, FALSE, FALSE)]
delta_cols_2 <- delta_cols[c(FALSE, FALSE, TRUE, TRUE)]
return_chain_matrix <- chain_matrix
return_chain_matrix[,beta_cols] <- chain_matrix[,beta_cols] * -1
for(i in 1:n_flip_gammas){
return_chain_matrix[,gamma_cols_1[i]] <- chain_matrix[,gamma_cols_2[i]]
return_chain_matrix[,gamma_cols_2[i]] <- chain_matrix[,gamma_cols_1[i]]
}
for(i in 1:n_flip_deltas){
return_chain_matrix[,delta_cols_1[i]] <- chain_matrix[,delta_cols_2[i]]
return_chain_matrix[,delta_cols_2[i]] <- chain_matrix[,delta_cols_1[i]]
}
return(return_chain_matrix)
}
posterior_sample_fixed = check_and_fix_chains_2stage(n_chains = number_MCMC_chains,
chains_list = posterior_sample,
pistarjj_matrix = pistarjj,
pitildejjj_matrix = pitildejjj,
dim_x, dim_z, dim_v,
n_cat)
n_chains = number_MCMC_chains
chains_list = posterior_sample
pistarjj_matrix = pistarjj
pitildejjj_matrix = pitildejjj
fixed_output_list <- list()
for(i in 1:n_chains){
pistar11 = pistarjj_matrix[i, 1]
pistar22 = pistarjj_matrix[i, 2]
flip_pistar11 = 1 - pistar22
flip_pistar22 = 1 - pistar11
J = pistar11 + pistar22 - 1
J_flip = flip_pistar11 + flip_pistar22 - 1
output = if(J_flip <= J){
chains_list[[i]]
} else {label_switch_2stage(chains_list[[i]],
dim_x, dim_z, dim_v, n_cat)}
fixed_output_list[[i]] = output
}
pistar11 = pistarjj_matrix[i, 1]
pistar22 = pistarjj_matrix[i, 2]
flip_pistar11 = 1 - pistar22
flip_pistar22 = 1 - pistar11
J = pistar11 + pistar22 - 1
J_flip = flip_pistar11 + flip_pistar22 - 1
output = if(J_flip <= J){
chains_list[[i]]
} else {label_switch_2stage(chains_list[[i]],
dim_x, dim_z, dim_v, n_cat)}
head(chains_list[[1]])
#'   the first-stage observed outcome, \eqn{Y^*}, and the second-stage observed
#'   outcome \eqn{\tilde{Y}} can take.
#'
#' @return \code{label_switch_2stage} returns a named matrix of MCMC posterior samples for
#'   all parameters after performing label switching according the following pattern:
#'   all \eqn{\beta} terms are multiplied by -1, all \eqn{\gamma} and \eqn{\delta} terms are "swapped"
#'   with the opposite \code{j} index.
#'
#' @importFrom stats rnorm rmultinom
#'
label_switch_2stage <- function(chain_matrix, dim_x, dim_z, dim_v, n_cat){
beta_names <- paste0("beta[1,", 1:dim_x, "]")
gamma_names <- paste0("gamma1[1,", rep(1:n_cat, dim_z), ",", rep(1:dim_z, each = n_cat), "]")
delta_names <- paste0("gamma2[1,",
rep(1:n_cat, dim_v*dim_v), ",",
rep(rep(1:n_cat, each = dim_v), dim_v), ",",
rep(1:dim_v, each = n_cat * n_cat), "]")
beta_cols <- which(colnames(chain_matrix) %in% beta_names)
gamma_cols <- which(colnames(chain_matrix) %in% gamma_names)
delta_cols <- which(colnames(chain_matrix) %in% delta_names)
n_flip_gammas <- length(gamma_cols) / 2
gamma_cols_1 <- gamma_cols[c(TRUE, FALSE)]
gamma_cols_2 <- gamma_cols[c(FALSE, TRUE)]
n_flip_deltas <- length(delta_cols) / 2
delta_cols_1 <- delta_cols[c(TRUE, TRUE, FALSE, FALSE)]
delta_cols_2 <- delta_cols[c(FALSE, FALSE, TRUE, TRUE)]
return_chain_matrix <- chain_matrix
return_chain_matrix[,beta_cols] <- chain_matrix[,beta_cols] * -1
for(i in 1:n_flip_gammas){
return_chain_matrix[,gamma_cols_1[i]] <- chain_matrix[,gamma_cols_2[i]]
return_chain_matrix[,gamma_cols_2[i]] <- chain_matrix[,gamma_cols_1[i]]
}
for(i in 1:n_flip_deltas){
return_chain_matrix[,delta_cols_1[i]] <- chain_matrix[,delta_cols_2[i]]
return_chain_matrix[,delta_cols_2[i]] <- chain_matrix[,delta_cols_1[i]]
}
return(return_chain_matrix)
}
output = if(J_flip <= J){
chains_list[[i]]
} else {label_switch_2stage(chains_list[[i]],
dim_x, dim_z, dim_v, n_cat)}
posterior_sample_fixed = check_and_fix_chains_2stage(n_chains = number_MCMC_chains,
chains_list = posterior_sample,
pistarjj_matrix = pistarjj,
pitildejjj_matrix = pitildejjj,
dim_x, dim_z, dim_v,
n_cat)
posterior_sample_df <- do.call(rbind.data.frame, posterior_sample_fixed)
posterior_sample_df$chain_number <- rep(1:number_MCMC_chains, each = MCMC_sample)
posterior_sample_df$sample <- rep(1:MCMC_sample, number_MCMC_chains)
##########################################
naive_modelstring = naive_model_picker_2stage(prior)
devtools::install_github("kimberlywebb/COMBO")
detach("package:COMBO", unload = TRUE)
library(COMBO)
detach("package:COMBO", unload = TRUE)
devtools::install_github("kimberlywebb/COMBO")
devtools::install_github("kimberlywebb/COMBO")
devtools::document()
devtools::install_github("kimberlywebb/COMBO")
library(COMBO)
detach("package:COMBO", unload = TRUE)
devtools::install_github("kimberlywebb/COMBO")
# Estimate parameters using MCMC.
MCMC_results <- COMBO_MCMC_2stage(Ystar1, Ystar2,
x_matrix = x_matrix,
z1_matrix = z1_matrix,
z2_matrix = z2_matrix,
prior = "uniform",
beta_prior_parameters,
gamma1_prior_parameters,
gamma2_prior_parameters,
naive_gamma2_prior_parameters = gamma1_prior_parameters,
number_MCMC_chains = 4,
MCMC_sample = 6, burn_in = 2)
library(COMBO)
pkgdown::build_site()
pkgdown::build_site()
devtools::check()
devtools::install_github("kimberlywebb/COMBO")
knitr::opts_chunk$set(echo = TRUE,
warning = FALSE, error = FALSE, message = FALSE,
fig.align = "center")
library(ggplot2)
library(kableExtra)
library(COMBO)
library(dplyr)
library(stringr)
# Set seed.
set.seed(123)
# Set sample size, x and z distribution information.
n <- 1000
x_mu <- 0
x_sigma <- 1
z1_shape <- 1
z2_shape <- 1
# Set true parameter values.
true_beta <- matrix(c(1, -2), ncol = 1)
true_gamma1 <- matrix(c(.5, 1, -.5, -1), nrow = 2, byrow = FALSE)
true_gamma2 <- array(c(1.5, 1, .5, .5, -.5, 0, -1, -1), dim = c(2, 2, 2))
# Generate data.
my_data <- COMBO_data_2stage(sample_size = n,
x_mu = x_mu, x_sigma = x_sigma,
z1_shape = z1_shape, z2_shape = z2_shape,
beta = true_beta, gamma1 = true_gamma1,
gamma2 = true_gamma2)
# Save list elements as vectors.
Ystar1 <- my_data[["obs_Ystar1"]]
Ystar2 <- my_data[["obs_Ystar2"]]
x_matrix <- my_data[["x"]]
z1_matrix <- my_data[["z1"]]
z2_matrix <- my_data[["z2"]]
# Supply starting values for all parameters.
starting_values <- rep(1,14)
beta_start <- matrix(starting_values[1:2], ncol = 1)
gamma1_start <- matrix(starting_values[3:6], ncol = 2, nrow = 2, byrow = FALSE)
gamma2_start <- array(starting_values[7:14], dim = c(2,2,2))
# Estimate parameters using the EM-Algorithm.
EM_results <- COMBO_EM_2stage(Ystar1, Ystar2,
x_matrix = x_matrix,
z1_matrix = z1_matrix,
z2_matrix = z2_matrix,
beta_start = beta_start,
gamma1_start = gamma1_start,
gamma2_start = gamma2_start)
EM_results
# Specify parameters for the prior distributions.
unif_lower_beta <- matrix(c(-5, -5, NA, NA), nrow = 2, byrow = TRUE)
unif_upper_beta <- matrix(c(5, 5, NA, NA), nrow = 2, byrow = TRUE)
unif_lower_gamma1 <- array(data = c(-5, NA, -5, NA, -5, NA, -5, NA),
dim = c(2,2,2))
unif_upper_gamma1 <- array(data = c(5, NA, 5, NA, 5, NA, 5, NA),
dim = c(2,2,2))
unif_upper_gamma2 <- array(rep(c(5, NA), 8), dim = c(2,2,2,2))
unif_lower_gamma2 <- array(rep(c(-5, NA), 8), dim = c(2,2,2,2))
beta_prior_parameters <- list(lower = unif_lower_beta, upper = unif_upper_beta)
gamma1_prior_parameters <- list(lower = unif_lower_gamma1, upper = unif_upper_gamma1)
gamma2_prior_parameters <- list(lower = unif_lower_gamma2, upper = unif_upper_gamma2)
# Estimate parameters using MCMC.
MCMC_results <- COMBO_MCMC_2stage(Ystar1, Ystar2,
x_matrix = x_matrix,
z1_matrix = z1_matrix,
z2_matrix = z2_matrix,
prior = "uniform",
beta_prior_parameters,
gamma1_prior_parameters,
gamma2_prior_parameters,
naive_gamma2_prior_parameters = gamma1_prior_parameters,
number_MCMC_chains = 4,
MCMC_sample = 6, burn_in = 2)
#'                                   x_matrix = x_matrix, z1_matrix = z1_matrix,
#'                                   z2_matrix = z2_matrix,
#'                                   prior = "uniform",
#'                                   beta_prior_parameters = beta_prior_parameters,
#'                                   gamma1_prior_parameters = gamma1_prior_parameters,
#'                                   gamma2_prior_parameters = gamma2_prior_parameters,
#'                                   naive_gamma2_prior_parameters = naive_gamma2_prior_parameters,
#'                                   number_MCMC_chains = 2,
#'                                   MCMC_sample = 200, burn_in = 100)
#' MCMC_results$posterior_means_df}
COMBO_MCMC_2stage <- function(Ystar1, Ystar2, x_matrix, z1_matrix, z2_matrix,
prior,
beta_prior_parameters,
gamma1_prior_parameters,
gamma2_prior_parameters,
naive_gamma2_prior_parameters,
number_MCMC_chains = 4,
MCMC_sample = 2000,
burn_in = 1000,
display_progress = TRUE){
Ystar <- Ystar1
Ytilde <- Ystar2
x <- x_matrix
z <- z1_matrix
v <- z2_matrix
gamma_prior_parameters <- gamma1_prior_parameters
delta_prior_parameters <- gamma2_prior_parameters
naive_delta_prior_parameters <- naive_gamma2_prior_parameters
# Define global variables to make the "NOTES" happy.
chain_number <- NULL
parameter_name <- NULL
if (!is.numeric(Ystar) || !is.vector(Ystar))
stop("'Ystar' must be a numeric vector.")
if (length(setdiff(1:2, unique(Ystar))) != 0)
stop("'Ystar' must be coded 1/2, where the reference category is 2.")
sample_size = length(Ystar)
n_cat = 2
# FIX THIS! DIMENSIONS DON'T WORK FOR x, z WITH MORE THAN ONE COL
X = cbind(matrix(1, nrow = sample_size, ncol = 1), x)
Z = cbind(matrix(1, nrow = sample_size, ncol = 1), z)
V = cbind(matrix(1, nrow = sample_size, ncol = 1), v)
dim_x = ncol(X)
dim_z = ncol(Z)
dim_v = ncol(V)
modelstring = model_picker_2stage(prior)
temp_model_file = tempfile()
tmps = file(temp_model_file, "w")
cat(modelstring, file = tmps)
close(tmps)
jags <- jags_picker_2stage(prior, sample_size, dim_x, dim_z, dim_v, n_cat,
Ystar, Ytilde, X, Z, V,
beta_prior_parameters, gamma_prior_parameters,
delta_prior_parameters,
number_MCMC_chains,
model_file = temp_model_file,
display_progress = display_progress)
display_progress_bar <- ifelse(display_progress == TRUE, "text", "none")
posterior_sample = coda.samples(jags,
c('beta', 'gamma1', 'gamma2'),
MCMC_sample,
progress.bar = display_progress_bar)
pistarjj = pistar_by_chain_2stage(n_chains = number_MCMC_chains,
chains_list = posterior_sample,
Z = Z, n = sample_size, n_cat = n_cat)
pitildejjj = pitilde_by_chain(n_chains = number_MCMC_chains,
chains_list = posterior_sample,
V = V, n = sample_size, n_cat = n_cat)
posterior_sample_fixed = check_and_fix_chains_2stage(n_chains = number_MCMC_chains,
chains_list = posterior_sample,
pistarjj_matrix = pistarjj,
pitildejjj_matrix = pitildejjj,
dim_x, dim_z, dim_v,
n_cat)
posterior_sample_df <- do.call(rbind.data.frame, posterior_sample_fixed)
posterior_sample_df$chain_number <- rep(1:number_MCMC_chains, each = MCMC_sample)
posterior_sample_df$sample <- rep(1:MCMC_sample, number_MCMC_chains)
##########################################
naive_modelstring = naive_model_picker_2stage(prior)
naive_temp_model_file = tempfile()
tmps = file(naive_temp_model_file, "w")
cat(naive_modelstring, file = tmps)
close(tmps)
naive_jags <- naive_jags_picker_2stage(prior, sample_size, dim_x, dim_v, n_cat,
Ystar, Ytilde, X, V,
beta_prior_parameters,
naive_delta_prior_parameters,
number_MCMC_chains,
naive_model_file = naive_temp_model_file,
display_progress = display_progress)
naive_posterior_sample = coda.samples(naive_jags,
c('beta', 'gamma'),
MCMC_sample,
progress.bar = display_progress_bar)
naive_posterior_sample_df <- do.call(rbind.data.frame, naive_posterior_sample)
naive_posterior_sample_df$chain_number <- rep(1:number_MCMC_chains, each = MCMC_sample)
naive_posterior_sample_df$sample <- rep(1:MCMC_sample, number_MCMC_chains)
###########################################
beta_names <- paste0("beta[1,", 1:dim_x, "]")
gamma_names <- paste0("gamma1[1,", rep(1:n_cat, dim_z), ",", rep(1:dim_z, each = n_cat), "]")
delta_names <- paste0("gamma2[1,",
rep(1:n_cat, dim_v*dim_v), ",",
rep(rep(1:n_cat, each = dim_v), dim_v), ",",
rep(1:dim_v, each = n_cat * n_cat), "]")
naive_delta_names <- paste0("gamma[1,", rep(1:n_cat, dim_v), ",", rep(1:dim_z, each = n_cat), "]")
naive_posterior_sample_burn <- naive_posterior_sample_df %>%
dplyr::select(dplyr::all_of(beta_names), dplyr::all_of(naive_delta_names),
chain_number, sample) %>%
dplyr::filter(sample > burn_in) %>%
tidyr::gather(parameter_name, sample, beta_names[1]:naive_delta_names[length(naive_delta_names)],
factor_key = TRUE) %>%
dplyr::mutate(parameter_name = paste0("naive_", parameter_name))
naive_posterior_means <- naive_posterior_sample_burn %>%
dplyr::group_by(parameter_name) %>%
dplyr::summarise(posterior_mean = mean(sample),
posterior_median = stats::median(sample)) %>%
dplyr::ungroup()
posterior_sample_burn <- posterior_sample_df %>%
dplyr::select(dplyr::all_of(beta_names), dplyr::all_of(gamma_names),
dplyr::all_of(delta_names),
chain_number, sample) %>%
dplyr::filter(sample > burn_in) %>%
tidyr::gather(parameter_name, sample,
beta_names[1]:delta_names[length(delta_names)], factor_key = TRUE)
posterior_means <- posterior_sample_burn %>%
dplyr::group_by(parameter_name) %>%
dplyr::summarise(posterior_mean = mean(sample),
posterior_median = stats::median(sample)) %>%
dplyr::ungroup()
results = list(posterior_sample_df = posterior_sample_burn,
posterior_means_df = posterior_means,
naive_posterior_sample_df = naive_posterior_sample_burn,
naive_posterior_means_df = naive_posterior_means)
return(results)
}
# Estimate parameters using MCMC.
MCMC_results <- COMBO_MCMC_2stage(Ystar1, Ystar2,
x_matrix = x_matrix,
z1_matrix = z1_matrix,
z2_matrix = z2_matrix,
prior = "uniform",
beta_prior_parameters,
gamma1_prior_parameters,
gamma2_prior_parameters,
naive_gamma2_prior_parameters = gamma1_prior_parameters,
number_MCMC_chains = 4,
MCMC_sample = 6, burn_in = 2)
rm(COMBO_MCMC_2stage)
devtools::document()
library(COMBO)
detach("package:COMBO", unload = TRUE)
devtools::install_github("kimberlywebb/COMBO")
knitr::opts_chunk$set(echo = TRUE,
warning = FALSE, error = FALSE, message = FALSE,
fig.align = "center")
library(ggplot2)
library(kableExtra)
library(COMBO)
library(dplyr)
library(stringr)
# Set seed.
set.seed(123)
# Set sample size, x and z distribution information.
n <- 1000
x_mu <- 0
x_sigma <- 1
z1_shape <- 1
z2_shape <- 1
# Set true parameter values.
true_beta <- matrix(c(1, -2), ncol = 1)
true_gamma1 <- matrix(c(.5, 1, -.5, -1), nrow = 2, byrow = FALSE)
true_gamma2 <- array(c(1.5, 1, .5, .5, -.5, 0, -1, -1), dim = c(2, 2, 2))
# Generate data.
my_data <- COMBO_data_2stage(sample_size = n,
x_mu = x_mu, x_sigma = x_sigma,
z1_shape = z1_shape, z2_shape = z2_shape,
beta = true_beta, gamma1 = true_gamma1,
gamma2 = true_gamma2)
devtools::install_github("kimberlywebb/COMBO")
knitr::opts_chunk$set(echo = TRUE,
warning = FALSE, error = FALSE, message = FALSE,
fig.align = "center")
library(ggplot2)
library(kableExtra)
library(COMBO)
library(dplyr)
library(stringr)
# Set seed.
set.seed(123)
# Set sample size, x and z distribution information.
n <- 1000
x_mu <- 0
x_sigma <- 1
z1_shape <- 1
z2_shape <- 1
# Set true parameter values.
true_beta <- matrix(c(1, -2), ncol = 1)
true_gamma1 <- matrix(c(.5, 1, -.5, -1), nrow = 2, byrow = FALSE)
true_gamma2 <- array(c(1.5, 1, .5, .5, -.5, 0, -1, -1), dim = c(2, 2, 2))
# Generate data.
my_data <- COMBO_data_2stage(sample_size = n,
x_mu = x_mu, x_sigma = x_sigma,
z1_shape = z1_shape, z2_shape = z2_shape,
beta = true_beta, gamma1 = true_gamma1,
gamma2 = true_gamma2)
# Save list elements as vectors.
Ystar1 <- my_data[["obs_Ystar1"]]
Ystar2 <- my_data[["obs_Ystar2"]]
x_matrix <- my_data[["x"]]
z1_matrix <- my_data[["z1"]]
z2_matrix <- my_data[["z2"]]
# Supply starting values for all parameters.
starting_values <- rep(1,14)
beta_start <- matrix(starting_values[1:2], ncol = 1)
gamma1_start <- matrix(starting_values[3:6], ncol = 2, nrow = 2, byrow = FALSE)
gamma2_start <- array(starting_values[7:14], dim = c(2,2,2))
# Estimate parameters using the EM-Algorithm.
EM_results <- COMBO_EM_2stage(Ystar1, Ystar2,
x_matrix = x_matrix,
z1_matrix = z1_matrix,
z2_matrix = z2_matrix,
beta_start = beta_start,
gamma1_start = gamma1_start,
gamma2_start = gamma2_start)
EM_results
# Specify parameters for the prior distributions.
unif_lower_beta <- matrix(c(-5, -5, NA, NA), nrow = 2, byrow = TRUE)
unif_upper_beta <- matrix(c(5, 5, NA, NA), nrow = 2, byrow = TRUE)
unif_lower_gamma1 <- array(data = c(-5, NA, -5, NA, -5, NA, -5, NA),
dim = c(2,2,2))
unif_upper_gamma1 <- array(data = c(5, NA, 5, NA, 5, NA, 5, NA),
dim = c(2,2,2))
unif_upper_gamma2 <- array(rep(c(5, NA), 8), dim = c(2,2,2,2))
unif_lower_gamma2 <- array(rep(c(-5, NA), 8), dim = c(2,2,2,2))
beta_prior_parameters <- list(lower = unif_lower_beta, upper = unif_upper_beta)
gamma1_prior_parameters <- list(lower = unif_lower_gamma1, upper = unif_upper_gamma1)
gamma2_prior_parameters <- list(lower = unif_lower_gamma2, upper = unif_upper_gamma2)
# Estimate parameters using MCMC.
MCMC_results <- COMBO_MCMC_2stage(Ystar1, Ystar2,
x_matrix = x_matrix,
z1_matrix = z1_matrix,
z2_matrix = z2_matrix,
prior = "uniform",
beta_prior_parameters,
gamma1_prior_parameters,
gamma2_prior_parameters,
naive_gamma2_prior_parameters = gamma1_prior_parameters,
number_MCMC_chains = 4,
MCMC_sample = 6, burn_in = 2)
devtools::document()
library(COMBO)
detach("package:COMBO", unload = TRUE)
devtools::install_github("kimberlywebb/COMBO")
