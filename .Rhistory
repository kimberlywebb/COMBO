delta_j1 <- matrix(chain_colMeans[delta_names[delta_j1_names]],
ncol = 2, byrow = TRUE)
delta_j2 <- matrix(chain_colMeans[delta_names[delta_j2_names]],
ncol = 2, byrow = TRUE)
delta <- array(c(delta_j1, delta_j2), dim = c(dim_v, n_cat, n_cat))
exp_vd1 = exp(V %*% delta[,,1])
exp_vd2 = exp(V %*% delta[,,2])
pi_denominator1 = apply(exp_vd1, FUN = sum_every_n1, n, MARGIN = 2)
pi_result1 = exp_vd1 / rbind(pi_denominator1)
pi_denominator2 = apply(exp_vd2, FUN = sum_every_n1, n, MARGIN = 2)
pi_result2 = exp_vd2 / rbind(pi_denominator2)
pitilde_matrix1 = rbind(pi_result1,
1 - apply(pi_result1,
FUN = sum_every_n, n = n,
MARGIN = 2))
pitilde_matrix2 = rbind(pi_result2,
1 - apply(pi_result2,
FUN = sum_every_n, n = n,
MARGIN = 2))
pitilde_array = array(c(pitilde_matrix1, pitilde_matrix2),
dim = c(dim(pitilde_matrix1), 2))
return(pitilde_array)
}
pistarjj = pistar_by_chain(n_chains = number_MCMC_chains,
chains_list = posterior_sample,
Z = Z, n = sample_size, n_cat = n_cat)
#' Sum Every "n"th Element
#'
#' @param x A numeric vector to sum over
#' @param n A numeric value specifying the distance between the reference index and the next index to be summed
#'
#' @return \code{sum_every_n} returns a vector of sums of every \code{n}^{th} element of the vector \code{x}.
#'
sum_every_n <- function(x, n){
vector_groups = split(x,
ceiling(seq_along(x) / n))
sum_x = Reduce(`+`, vector_groups)
return(sum_x)
}
pistarjj = pistar_by_chain(n_chains = number_MCMC_chains,
chains_list = posterior_sample,
Z = Z, n = sample_size, n_cat = n_cat)
#' @param j An integer value representing the true outcome category to compute
#'   the average conditional probability of correct classification for.
#'   \code{j} can take on values \code{1} and \code{2}.
#' @param sample_size An integer value specifying the number of observations in the sample.
#'
#' @return \code{mean_pistarjj_compute} returns a numeric value equal to the average
#'   conditional probability \eqn{P(Y^* = j | Y = j, Z)} across all subjects.
#'
#' @importFrom stats rnorm
#'
mean_pistarjj_compute <- function(pistar_matrix, j, sample_size){
k_index = ifelse(j == 1, 1:sample_size,
ifelse(j == 2, (sample_size + 1):(sample_size*2), NA))
mean_pistar = mean(pistar_matrix[k_index, j])
return(mean_pistar)
}
pistarjj = pistar_by_chain(n_chains = number_MCMC_chains,
chains_list = posterior_sample,
Z = Z, n = sample_size, n_cat = n_cat)
pitildejjj = pitilde_by_chain(n_chains = number_MCMC_chains,
chains_list = posterior_sample,
V = V, n = sample_size, n_cat = n_cat)
#'   conditional probability \eqn{P( \tilde{Y} = j | Y^* = j, Y = j, V)} across all subjects for
#'   each MCMC chain. Rows of the matrix correspond to MCMC chains, up to \code{n_chains}.
#'   The first column contains the conditional probability \eqn{P( \tilde{Y} = 1 | Y^* = 1, Y = 1, V)}.
#'   The second column contains the conditional probability \eqn{P( \tilde{Y} = 2 | Y^* = 2, Y = 2, V)}.
#'
#' @include pistar_compute_for_chains.R
#' @include mean_pistarjj_compute.R
#'
#' @importFrom stats rnorm
#'
pitilde_by_chain <- function(n_chains, chains_list, V, n, n_cat){
colmeans_by_chain = lapply(chains_list, colMeans)
pitilde_results = matrix(NA, nrow = n_chains, ncol = n_cat)
for(i in 1:n_chains){
chain_means_i = colmeans_by_chain[[i]]
pitilde_array_i = pitilde_compute_for_chains(chain_means_i, V, n, n_cat)
pitilde_results[i, 1] = mean(pitilde_array_i[1:n, 1, 1])
pitilde_results[i, 2] = mean(pitilde_array_i[(n + 1):(2 * n), 2, 2])
}
return(pitilde_results)
}
pitildejjj = pitilde_by_chain(n_chains = number_MCMC_chains,
chains_list = posterior_sample,
V = V, n = sample_size, n_cat = n_cat)
#' Sum Every "n"th Element, then add 1
#'
#' @param x A numeric vector to sum over
#' @param n A numeric value specifying the distance between the reference index and the next index to be summed
#'
#' @return \code{sum_every_n1} returns a vector of sums of every \code{n}^{th} element of the vector \code{x}, plus 1.
#'
sum_every_n1 <- function(x, n){
vector_groups = split(x,
ceiling(seq_along(x) / n))
sum_x = Reduce(`+`, vector_groups) + 1
return(sum_x)
}
pitildejjj = pitilde_by_chain(n_chains = number_MCMC_chains,
chains_list = posterior_sample,
V = V, n = sample_size, n_cat = n_cat)
posterior_sample_fixed = check_and_fix_chains_2stage(n_chains = number_MCMC_chains,
chains_list = posterior_sample,
pistarjj_matrix = pistarjj,
pitildejjj_matrix = pitildejjj,
dim_x, dim_z, dim_v,
n_cat)
#' @param dim_v The number of columns of the design matrix of the second-stage observation mechanism, \code{V}.
#' @param n_cat The number of categorical values that the true outcome, \code{Y},
#'   and the observed outcome, \code{Y*} can take.
#'
#' @return \code{check_and_fix_chains} returns a numeric list of the samples from
#'   \code{n_chains} MCMC chains which have been corrected for label switching if
#'   the following assumption is not met: \eqn{P(Y^* = j | Y = j, Z) > 0.50 \forall j}.
#'
#' @include label_switch.R
#'
check_and_fix_chains_2stage <- function(n_chains, chains_list,
pistarjj_matrix, pitildejjj_matrix,
dim_x, dim_z, dim_v, n_cat){
fixed_output_list <- list()
for(i in 1:n_chains){
pistar11 = pistarjj_matrix[i, 1]
pistar22 = pistarjj_matrix[i, 2]
flip_pistar11 = 1 - pistar22
flip_pistar22 = 1 - pistar11
J = pistar11 + pistar22 - 1
J_flip = flip_pistar11 + flip_pistar22 - 1
output = if(J_flip <= J){
chains_list[[i]]
} else {label_switch_2stage(chains_list[[i]],
dim_x, dim_z, dim_v, n_cat)}
fixed_output_list[[i]] = output
}
return(fixed_output_list)
}
posterior_sample_fixed = check_and_fix_chains_2stage(n_chains = number_MCMC_chains,
chains_list = posterior_sample,
pistarjj_matrix = pistarjj,
pitildejjj_matrix = pitildejjj,
dim_x, dim_z, dim_v,
n_cat)
n_chains = number_MCMC_chains
chains_list = posterior_sample
pistarjj_matrix = pistarjj
View(posterior_sample)
head(posterior_sample)
n_chains = number_MCMC_chains
chains_list = posterior_sample
n = sample_size
colmeans_by_chain = lapply(chains_list, colMeans)
colmeans_by_chain
pistar_results = matrix(NA, nrow = n_chains, ncol = n_cat)
for(i in 1:n_chains){
chain_means_i = colmeans_by_chain[[i]]
pistar_matrix_i = pistar_compute_for_chains(chain_means_i, Z, n, n_cat)
pistar_results[i, 1] = mean_pistarjj_compute(pistar_matrix_i, 1, n)
pistar_results[i, 2] = mean_pistarjj_compute(pistar_matrix_i, 2, n)
}
i  = 1
chain_means_i = colmeans_by_chain[[i]]
chain_means_i
pistar_matrix_i = pistar_compute_for_chains(chain_means_i, Z, n, n_cat)
#'   for each of the \eqn{i = 1, \dots,} \code{n} subjects. Rows of the matrix
#'   correspond to each subject and observed outcome. Specifically, the probability
#'   for subject \eqn{i} and observed category $0$ occurs at row \eqn{i}. The probability
#'   for subject \eqn{i} and observed category $1$ occurs at row \eqn{i +} \code{n}.
#'   Columns of the matrix correspond to the true outcome categories \eqn{j = 1, \dots,} \code{n_cat}.
#'
#' @include sum_every_n.R
#'
#' @importFrom stats rnorm
#'
pistar_compute_for_chains_2stage <- function(chain_colMeans, Z, n, n_cat){
dim_z = ncol(Z)
gamma_names <- paste0("gamma1[1,", rep(1:n_cat, dim_z), ",", rep(1:dim_z, each = n_cat), "]")
gamma = matrix(chain_colMeans[gamma_names],
ncol = 2, byrow = TRUE)
exp_zg_nobaseline = exp(Z %*% gamma)
exp_zg_baseline = matrix(1, nrow = n, ncol = n_cat)
exp_zg = rbind(exp_zg_nobaseline, exp_zg_baseline)
pi_denominator = apply(exp_zg, FUN = sum_every_n, n, MARGIN = 2)
pi_result = exp_zg / do.call("rbind", rep(list(pi_denominator),
n_cat))
return(pi_result)
}
pistar_matrix_i = pistar_compute_for_chains_2stage(chain_means_i, Z, n, n_cat)
pistar_results[i, 1] = mean_pistarjj_compute(pistar_matrix_i, 1, n)
pistar_results[i, 2] = mean_pistarjj_compute(pistar_matrix_i, 2, n)
pistarjj = pistar_by_chain_2stage(n_chains = number_MCMC_chains,
chains_list = posterior_sample,
Z = Z, n = sample_size, n_cat = n_cat)
#'   conditional probability \eqn{P(Y^* = j | Y = j, Z)} across all subjects for
#'   each MCMC chain. Rows of the matrix correspond to MCMC chains, up to \code{n_chains}.
#'   The first column contains the conditional probability \eqn{P(Y^* = 1 | Y = 1, Z)}.
#'   The second column contains the conditional probability \eqn{P(Y^* = 2 | Y = 2, Z)}.
#'
#' @include pistar_compute_for_chains.R
#' @include mean_pistarjj_compute.R
#'
#' @importFrom stats rnorm
#'
pistar_by_chain_2stage <- function(n_chains, chains_list, Z, n, n_cat){
colmeans_by_chain = lapply(chains_list, colMeans)
pistar_results = matrix(NA, nrow = n_chains, ncol = n_cat)
for(i in 1:n_chains){
chain_means_i = colmeans_by_chain[[i]]
pistar_matrix_i = pistar_compute_for_chains_2stage(chain_means_i, Z, n, n_cat)
pistar_results[i, 1] = mean_pistarjj_compute(pistar_matrix_i, 1, n)
pistar_results[i, 2] = mean_pistarjj_compute(pistar_matrix_i, 2, n)
}
return(pistar_results)
}
pistarjj = pistar_by_chain_2stage(n_chains = number_MCMC_chains,
chains_list = posterior_sample,
Z = Z, n = sample_size, n_cat = n_cat)
pitildejjj = pitilde_by_chain(n_chains = number_MCMC_chains,
chains_list = posterior_sample,
V = V, n = sample_size, n_cat = n_cat)
#'   for subject \eqn{i} and second-stage observed category $1$ occurs at row \eqn{i}. The probability
#'   for subject \eqn{i} and second-stage observed category $2$ occurs at row \eqn{i +} \code{n}.
#'   Columns of the matrix correspond to the first-stage outcome categories \eqn{j = 1, \dots,} \code{n_cat}.
#'   The third dimension of the array corresponds to the true outcome categories,
#'   \eqn{j = 1, \dots,} \code{n_cat}.
#'
#' @include sum_every_n.R
#'
#' @importFrom stats rnorm
#'
pitilde_compute_for_chains <- function(chain_colMeans, V, n, n_cat){
dim_v = ncol(V)
delta_names <- paste0("gamma2[1,",
rep(1:n_cat, dim_v*dim_v), ",",
rep(rep(1:n_cat, each = dim_v), dim_v), ",",
rep(1:dim_v, each = n_cat * n_cat), "]")
delta_j1_names <- which(substring(delta_names, 11, 11) == 1)
delta_j2_names <- which(substring(delta_names, 11, 11) == 2)
delta_j1 <- matrix(chain_colMeans[delta_names[delta_j1_names]],
ncol = 2, byrow = TRUE)
delta_j2 <- matrix(chain_colMeans[delta_names[delta_j2_names]],
ncol = 2, byrow = TRUE)
delta <- array(c(delta_j1, delta_j2), dim = c(dim_v, n_cat, n_cat))
exp_vd1 = exp(V %*% delta[,,1])
exp_vd2 = exp(V %*% delta[,,2])
pi_denominator1 = apply(exp_vd1, FUN = sum_every_n1, n, MARGIN = 2)
pi_result1 = exp_vd1 / rbind(pi_denominator1)
pi_denominator2 = apply(exp_vd2, FUN = sum_every_n1, n, MARGIN = 2)
pi_result2 = exp_vd2 / rbind(pi_denominator2)
pitilde_matrix1 = rbind(pi_result1,
1 - apply(pi_result1,
FUN = sum_every_n, n = n,
MARGIN = 2))
pitilde_matrix2 = rbind(pi_result2,
1 - apply(pi_result2,
FUN = sum_every_n, n = n,
MARGIN = 2))
pitilde_array = array(c(pitilde_matrix1, pitilde_matrix2),
dim = c(dim(pitilde_matrix1), 2))
return(pitilde_array)
}
pitildejjj = pitilde_by_chain(n_chains = number_MCMC_chains,
chains_list = posterior_sample,
V = V, n = sample_size, n_cat = n_cat)
colmeans_by_chain = lapply(chains_list, colMeans)
chain_means_i = colmeans_by_chain[[i]]
pitilde_array_i = pitilde_compute_for_chains(chain_means_i, V, n, n_cat)
delta_names <- paste0("gamma2[1,",
rep(1:n_cat, dim_v*dim_v), ",",
rep(rep(1:n_cat, each = dim_v), dim_v), ",",
rep(1:dim_v, each = n_cat * n_cat), "]")
dim_v = ncol(V)
delta_j1_names <- which(substring(delta_names, 11, 11) == 1)
head(delta_names)
head(chains_list)
substring(delta_names, 11, 11)
delta_names
?substring
delta_j1_names <- which(substring(delta_names, 12, 12) == 1)
delta_j2_names <- which(substring(delta_names, 12, 12) == 2)
delta_j1 <- matrix(chain_colMeans[delta_names[delta_j1_names]],
ncol = 2, byrow = TRUE)
chain_colMeans = chain_means_i
delta_j2 <- matrix(chain_colMeans[delta_names[delta_j2_names]],
ncol = 2, byrow = TRUE)
delta <- array(c(delta_j1, delta_j2), dim = c(dim_v, n_cat, n_cat))
delta_j1 <- matrix(chain_colMeans[delta_names[delta_j1_names]],
ncol = 2, byrow = TRUE)
delta_j2 <- matrix(chain_colMeans[delta_names[delta_j2_names]],
ncol = 2, byrow = TRUE)
delta <- array(c(delta_j1, delta_j2), dim = c(dim_v, n_cat, n_cat))
exp_vd1 = exp(V %*% delta[,,1])
exp_vd2 = exp(V %*% delta[,,2])
pi_denominator1 = apply(exp_vd1, FUN = sum_every_n1, n, MARGIN = 2)
pi_result1 = exp_vd1 / rbind(pi_denominator1)
pi_denominator2 = apply(exp_vd2, FUN = sum_every_n1, n, MARGIN = 2)
pi_result2 = exp_vd2 / rbind(pi_denominator2)
pitilde_matrix1 = rbind(pi_result1,
1 - apply(pi_result1,
FUN = sum_every_n, n = n,
MARGIN = 2))
pitilde_matrix2 = rbind(pi_result2,
1 - apply(pi_result2,
FUN = sum_every_n, n = n,
MARGIN = 2))
pitilde_array = array(c(pitilde_matrix1, pitilde_matrix2),
dim = c(dim(pitilde_matrix1), 2))
#'   for subject \eqn{i} and second-stage observed category $1$ occurs at row \eqn{i}. The probability
#'   for subject \eqn{i} and second-stage observed category $2$ occurs at row \eqn{i +} \code{n}.
#'   Columns of the matrix correspond to the first-stage outcome categories \eqn{j = 1, \dots,} \code{n_cat}.
#'   The third dimension of the array corresponds to the true outcome categories,
#'   \eqn{j = 1, \dots,} \code{n_cat}.
#'
#' @include sum_every_n.R
#'
#' @importFrom stats rnorm
#'
pitilde_compute_for_chains <- function(chain_colMeans, V, n, n_cat){
dim_v = ncol(V)
delta_names <- paste0("gamma2[1,",
rep(1:n_cat, dim_v*dim_v), ",",
rep(rep(1:n_cat, each = dim_v), dim_v), ",",
rep(1:dim_v, each = n_cat * n_cat), "]")
delta_j1_names <- which(substring(delta_names, 12, 12) == 1)
delta_j2_names <- which(substring(delta_names, 12, 12) == 2)
delta_j1 <- matrix(chain_colMeans[delta_names[delta_j1_names]],
ncol = 2, byrow = TRUE)
delta_j2 <- matrix(chain_colMeans[delta_names[delta_j2_names]],
ncol = 2, byrow = TRUE)
delta <- array(c(delta_j1, delta_j2), dim = c(dim_v, n_cat, n_cat))
exp_vd1 = exp(V %*% delta[,,1])
exp_vd2 = exp(V %*% delta[,,2])
pi_denominator1 = apply(exp_vd1, FUN = sum_every_n1, n, MARGIN = 2)
pi_result1 = exp_vd1 / rbind(pi_denominator1)
pi_denominator2 = apply(exp_vd2, FUN = sum_every_n1, n, MARGIN = 2)
pi_result2 = exp_vd2 / rbind(pi_denominator2)
pitilde_matrix1 = rbind(pi_result1,
1 - apply(pi_result1,
FUN = sum_every_n, n = n,
MARGIN = 2))
pitilde_matrix2 = rbind(pi_result2,
1 - apply(pi_result2,
FUN = sum_every_n, n = n,
MARGIN = 2))
pitilde_array = array(c(pitilde_matrix1, pitilde_matrix2),
dim = c(dim(pitilde_matrix1), 2))
return(pitilde_array)
}
posterior_sample_fixed = check_and_fix_chains_2stage(n_chains = number_MCMC_chains,
chains_list = posterior_sample,
pistarjj_matrix = pistarjj,
pitildejjj_matrix = pitildejjj,
dim_x, dim_z, dim_v,
n_cat)
pitildejjj = pitilde_by_chain(n_chains = number_MCMC_chains,
chains_list = posterior_sample,
V = V, n = sample_size, n_cat = n_cat)
#'   the first-stage observed outcome, \eqn{Y^*}, and the second-stage observed
#'   outcome \eqn{\tilde{Y}} can take.
#'
#' @return \code{label_switch_2stage} returns a named matrix of MCMC posterior samples for
#'   all parameters after performing label switching according the following pattern:
#'   all \eqn{\beta} terms are multiplied by -1, all \eqn{\gamma} and \eqn{\delta} terms are "swapped"
#'   with the opposite \code{j} index.
#'
#' @importFrom stats rnorm rmultinom
#'
label_switch_2stage <- function(chain_matrix, dim_x, dim_z, dim_v, n_cat){
beta_names <- paste0("beta[1,", 1:dim_x, "]")
gamma_names <- paste0("gamma[1,", rep(1:n_cat, dim_z), ",", rep(1:dim_z, each = n_cat), "]")
delta_names <- paste0("delta[1,",
rep(1:n_cat, dim_v*dim_v), ",",
rep(rep(1:n_cat, each = dim_v), dim_v), ",",
rep(1:dim_v, each = n_cat * n_cat), "]")
beta_cols <- which(colnames(chain_matrix) %in% beta_names)
gamma_cols <- which(colnames(chain_matrix) %in% gamma_names)
delta_cols <- which(colnames(chain_matrix) %in% delta_names)
n_flip_gammas <- length(gamma_cols) / 2
gamma_cols_1 <- gamma_cols[c(TRUE, FALSE)]
gamma_cols_2 <- gamma_cols[c(FALSE, TRUE)]
n_flip_deltas <- length(delta_cols) / 2
delta_cols_1 <- delta_cols[c(TRUE, TRUE, FALSE, FALSE)]
delta_cols_2 <- delta_cols[c(FALSE, FALSE, TRUE, TRUE)]
return_chain_matrix <- chain_matrix
return_chain_matrix[,beta_cols] <- chain_matrix[,beta_cols] * -1
for(i in 1:n_flip_gammas){
return_chain_matrix[,gamma_cols_1[i]] <- chain_matrix[,gamma_cols_2[i]]
return_chain_matrix[,gamma_cols_2[i]] <- chain_matrix[,gamma_cols_1[i]]
}
for(i in 1:n_flip_deltas){
return_chain_matrix[,delta_cols_1[i]] <- chain_matrix[,delta_cols_2[i]]
return_chain_matrix[,delta_cols_2[i]] <- chain_matrix[,delta_cols_1[i]]
}
return(return_chain_matrix)
}
posterior_sample_fixed = check_and_fix_chains_2stage(n_chains = number_MCMC_chains,
chains_list = posterior_sample,
pistarjj_matrix = pistarjj,
pitildejjj_matrix = pitildejjj,
dim_x, dim_z, dim_v,
n_cat)
n_chains = number_MCMC_chains
chains_list = posterior_sample
pistarjj_matrix = pistarjj
pitildejjj_matrix = pitildejjj
fixed_output_list <- list()
for(i in 1:n_chains){
pistar11 = pistarjj_matrix[i, 1]
pistar22 = pistarjj_matrix[i, 2]
flip_pistar11 = 1 - pistar22
flip_pistar22 = 1 - pistar11
J = pistar11 + pistar22 - 1
J_flip = flip_pistar11 + flip_pistar22 - 1
output = if(J_flip <= J){
chains_list[[i]]
} else {label_switch_2stage(chains_list[[i]],
dim_x, dim_z, dim_v, n_cat)}
fixed_output_list[[i]] = output
}
pistar11 = pistarjj_matrix[i, 1]
pistar22 = pistarjj_matrix[i, 2]
flip_pistar11 = 1 - pistar22
flip_pistar22 = 1 - pistar11
J = pistar11 + pistar22 - 1
J_flip = flip_pistar11 + flip_pistar22 - 1
output = if(J_flip <= J){
chains_list[[i]]
} else {label_switch_2stage(chains_list[[i]],
dim_x, dim_z, dim_v, n_cat)}
head(chains_list[[1]])
#'   the first-stage observed outcome, \eqn{Y^*}, and the second-stage observed
#'   outcome \eqn{\tilde{Y}} can take.
#'
#' @return \code{label_switch_2stage} returns a named matrix of MCMC posterior samples for
#'   all parameters after performing label switching according the following pattern:
#'   all \eqn{\beta} terms are multiplied by -1, all \eqn{\gamma} and \eqn{\delta} terms are "swapped"
#'   with the opposite \code{j} index.
#'
#' @importFrom stats rnorm rmultinom
#'
label_switch_2stage <- function(chain_matrix, dim_x, dim_z, dim_v, n_cat){
beta_names <- paste0("beta[1,", 1:dim_x, "]")
gamma_names <- paste0("gamma1[1,", rep(1:n_cat, dim_z), ",", rep(1:dim_z, each = n_cat), "]")
delta_names <- paste0("gamma2[1,",
rep(1:n_cat, dim_v*dim_v), ",",
rep(rep(1:n_cat, each = dim_v), dim_v), ",",
rep(1:dim_v, each = n_cat * n_cat), "]")
beta_cols <- which(colnames(chain_matrix) %in% beta_names)
gamma_cols <- which(colnames(chain_matrix) %in% gamma_names)
delta_cols <- which(colnames(chain_matrix) %in% delta_names)
n_flip_gammas <- length(gamma_cols) / 2
gamma_cols_1 <- gamma_cols[c(TRUE, FALSE)]
gamma_cols_2 <- gamma_cols[c(FALSE, TRUE)]
n_flip_deltas <- length(delta_cols) / 2
delta_cols_1 <- delta_cols[c(TRUE, TRUE, FALSE, FALSE)]
delta_cols_2 <- delta_cols[c(FALSE, FALSE, TRUE, TRUE)]
return_chain_matrix <- chain_matrix
return_chain_matrix[,beta_cols] <- chain_matrix[,beta_cols] * -1
for(i in 1:n_flip_gammas){
return_chain_matrix[,gamma_cols_1[i]] <- chain_matrix[,gamma_cols_2[i]]
return_chain_matrix[,gamma_cols_2[i]] <- chain_matrix[,gamma_cols_1[i]]
}
for(i in 1:n_flip_deltas){
return_chain_matrix[,delta_cols_1[i]] <- chain_matrix[,delta_cols_2[i]]
return_chain_matrix[,delta_cols_2[i]] <- chain_matrix[,delta_cols_1[i]]
}
return(return_chain_matrix)
}
output = if(J_flip <= J){
chains_list[[i]]
} else {label_switch_2stage(chains_list[[i]],
dim_x, dim_z, dim_v, n_cat)}
posterior_sample_fixed = check_and_fix_chains_2stage(n_chains = number_MCMC_chains,
chains_list = posterior_sample,
pistarjj_matrix = pistarjj,
pitildejjj_matrix = pitildejjj,
dim_x, dim_z, dim_v,
n_cat)
posterior_sample_df <- do.call(rbind.data.frame, posterior_sample_fixed)
posterior_sample_df$chain_number <- rep(1:number_MCMC_chains, each = MCMC_sample)
posterior_sample_df$sample <- rep(1:MCMC_sample, number_MCMC_chains)
##########################################
naive_modelstring = naive_model_picker_2stage(prior)
devtools::install_github("kimberlywebb/COMBO")
detach("package:COMBO", unload = TRUE)
library(COMBO)
detach("package:COMBO", unload = TRUE)
devtools::install_github("kimberlywebb/COMBO")
devtools::install_github("kimberlywebb/COMBO")
devtools::document()
devtools::install_github("kimberlywebb/COMBO")
library(COMBO)
detach("package:COMBO", unload = TRUE)
devtools::install_github("kimberlywebb/COMBO")
# Estimate parameters using MCMC.
MCMC_results <- COMBO_MCMC_2stage(Ystar1, Ystar2,
x_matrix = x_matrix,
z1_matrix = z1_matrix,
z2_matrix = z2_matrix,
prior = "uniform",
beta_prior_parameters,
gamma1_prior_parameters,
gamma2_prior_parameters,
naive_gamma2_prior_parameters = gamma1_prior_parameters,
number_MCMC_chains = 4,
MCMC_sample = 6, burn_in = 2)
library(COMBO)
pkgdown::build_site()
pkgdown::build_site()
devtools::check()
